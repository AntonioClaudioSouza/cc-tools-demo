#
# Recurso de Persistent Volume
#
# Inicialmente, como nossa aplicação necessita de volume.
# Então, será solicitado um recurso de volume persistente (PV)
# ao orquestrador (k8s, Kubernetes)
#
apiVersion: v1                                  # Api k8s
kind: PersistentVolume
metadata:
  name: pv-cc-webclient
spec:
  capacity:
   storage: 1Gi
  volumeMode: Filesystem
  accessModes:
   - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
   path: /nfsshare
   server: 127.0.0.1   #Endereco do server onde será requerido o volume
---
#
# Recurso de PersistentVolumeClaim
#
# Com o PV definido, agora vamos nos 'conectar' a ele criando um PVC
# Dessa forma faremos um 'bind' no persistentVolume
#
apiVersion: v1                                  # Api k8s
kind: PersistentVolumeClaim
metadata:
  name: pvc-cc-webclient 
spec:
  volumeName: pv-cc-webclient
  accessModes:
   - ReadWriteMany
  resources:
   requests:
    storage: 1Gi
---
#
# Recurso de Deploy no OpenShift -> DeploymentConfig
#
# Criação do deploy de nossa aplicação
#
apiVersion: apps.openshift.io/v1                # Exclusivo OpenShift
kind: DeploymentConfig                          # Exclusivo OpenShift
metadata:
  labels:
    app: cc-webclient                           
  name: cc-webclient                            # Nome do nosso deploy
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    app: cc-webclient                           
    deploymentconfig: cc-webclient              
  strategy:
    activeDeadlineSeconds: 21600
    resources: {}
    rollingParams:
      intervalSeconds: 1
      maxSurge: 25%
      maxUnavailable: 25%
      timeoutSeconds: 600
      updatePeriodSeconds: 1
    type: Rolling
  template:
    metadata:
      labels:
        app: cc-webclient                       # LABEL DE NOSSA APLICAÇÃO
        deploymentconfig: cc-webclient
    spec:
      containers:
      - image: docker.io/goledger/cc-webclient
        imagePullPolicy: Always
        name: cc-webclient                      # LABEL DA NOSSA APLICACAO
        ports:
        - containerPort: 80
          protocol: TCP
        resources:
          requests:
            cpu: 10m
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /media
          name: label-pv-pod                # LABEL DO PV DEFINIDO NA SESSÃO DE VOLUME PERSISTENTE (INICIO DO ARQUIVO)
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}   
      serviceAccount: anyuid-root
      serviceAccountName: anyuid-root
      terminationGracePeriodSeconds: 30      
      volumes:
        - name: label-pv-pod          
          persistenteVolumeClaim:
            claimName: pvc-cc-webclient
      #- emptyDir: {}
      #- name: pv-cc-webclient2                   # LABEL DO PV DEFINIDO NA SESSÃO DE VOLUME PERSISTENTE (INICIO DO ARQUIVO)
      #  hostPath:
      #    path: /var/log
---
#
# Recurso Service, para expor seu  Pod ao mundo
#
# Criação do service para acesso EXTERNO ao nosso cluster
# usando NodePort
#
apiVersion: v1                                  # Api k8s
kind: Service
metadata:
  labels:
    app: cc-webclient                           # LABEL DA NOSSA APLICACAO E NAO DO RECURSO A SER CRIADO
  name: service-cc-webclient                    # Nome do recurso a ser criado
spec:
  externalTrafficPolicy: Cluster
  ports:
  - name: 80-tcp
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: cc-webclient                           # LABEL DA NOSSA APLICACAO
    deploymentconfig: cc-webclient              # LABEL DA NOSSO RECURSO DE DEPLOYMENTCONFIG 
  sessionAffinity: None
  type: NodePort
---
#
# Recurso de Route para o mundo chegar até seu Pod
#
# Criação da ROTA para chegarmos até o nosso service da aplicação
# 
apiVersion: route.openshift.io/v1               # Exclusivo OpenShift
kind: Route
metadata:  
  labels:
    app: cc-webclient                           # LABEL DA NOSSA APLICACAO E NAO DO RECURSO A SER CRIADO
  name: route-cc-webclient                      # Nome do recurso a ser criado
spec:
  host: ccwebclient.app.oslab.goledger.io       
  port:
    targetPort: 80-tcp
  to:
    kind: Service
    name: service-cc-webclient                  # Nome de nosso 'service' que será entregue a conexão
    weight: 100
  wildcardPolicy: None 
---
#
# Recurso de AutoScaling para escalar horizontalmente sua aplicação
#
# Com base no uso de CPU.
# Obs, deve ser ativado o servidor de métricas
# Esse servidor, requer muitos recursos computacionais
# se poucos recursos, sua instância( seu node master ) não irá suportar.
#
#apiVersion: autoscaling/v2beta1                 # Api k8s
#kind: HorizontalPodAutoscaler
#metadata:
#  name: hpa-resource-metrics-cpu-cc-webclient
#spec:
#  scaleTargetRef:
#    apiVersion: apps.openshift.io/v1
#    kind: DeploymentConfig
#    name: cc-webclient
#  minReplicas: 1
#  maxReplicas: 10
#  metrics:
#    - type: Resource
#      resource:
#        name: cpu
#        targetAverageUtilization: 50